<book xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xml:id="book-docbook-rocks"
      version="5.0">
 <info>
   <title>DocBook rocks!</title>
 </info>

 <section xml:id="who-is-this-for">
   <title>Who this is for?</title>
   <para>
     <emphasis>Me:</emphasis> I'm a quick dive in to about ten DocBook
     tags which will let you get going and documenting pretty much
     everything you need.
   </para>
   <para>
     <emphasis>You:</emphasis> You're maybe a bit skeptical of DocBook,
     but need to write a page or two of documentation and got spooked
     by the extremely thorough and extremely intimidating <link
     xlink:href="https://tdg.docbook.org/">official
     documentation</link>.
   </para>
   <para>
     You have an open mind and aren't alergic to a
     <literal>&lt;</literal> and a <literal>&gt;</literal>.
   </para>
 </section>
 <section xml:id="why-docbook">
   <title>Why DocBook?</title>
   <para>
     The project you're working on may have chosen DocBook, and maybe
     you're not sure why. "But why not Markdown?" is something I
     hear a lot.
   </para>

   <para>
     In John Gruber's words, Markdown is not always the right tool for
     the job.

     <blockquote>
       <attribution>
         <link xlink:href="https://daringfireball.net/projects/markdown/syntax#philosophy">DaringFireball</link>
       </attribution>

       <simpara>
         The idea for Markdown is to make it easy to read, write, and
         edit prose. HTML is a publishing format; Markdown is a
         writing format. Thus, Markdown's formatting syntax only
         addresses issues that can be conveyed in plain text.
       </simpara>
     </blockquote>
   </para>

   <para>
     DocBook is really designed <emphasis>for</emphasis> documentation.
     Yes it is more verbose (<emphasis>explicit</emphasis>). Yeah, it
     uses some pointy bois (<literal>&lt;</literal>, <literal>&gt;</literal>)
     which aren't all a lot of fun to type.
   </para>

   <para>
     These explicit ways of marking up a document are a bit annoying
     when writing prose and paragraphs. However, they become helpful
     when doing more complicated things. DocBook has good and
     predictable built-in support for making tables, code snippets
     with inline annotations, checked cross-references between
     sections and many other features which are very useful for
     documenting complicated projects.
   </para>

   <para>
     DocBook is also much more than a format for writing to HTML.
     Using a free set of what is called "Stylesheets" (not CSS
     stylesheets) DocBook can be converted in to manpages, PDFs, and
     yes HTML. With DocBook, indexes and tables of contents come for
     free.
   </para>
 </section>

 <chapter xml:id="block-elements">
   <title>Block Elements</title>

   <section xml:id="paragraphs">
     <title>Paragraphs and Line Breaks</title>

     <example>
       <programlisting><xi:include href="./paras.xml" parse="text" /></programlisting>
       <xi:include href="./paras.xml" />
     </example>
   </section>

   <section xml:id="headers">
     <title>Headers</title>

     <para>
       DocBook automatically applies the right header for your
       content, based on its <emphasis>nesting</emphasis>.
     </para>

     <example>
       <programlisting><xi:include href="./headers.xml" parse="text" /></programlisting>
       <xi:include href="./headers.xml" />
     </example>


     <para>
       Sometimes, you may want a subtitle. DocBook supports that!
     </para>

     <example>
       <programlisting><xi:include href="./subtitles.xml" parse="text" /></programlisting>
       <xi:include href="./subtitles.xml" />
     </example>
   </section>

   <section xml:id="blockquotes">
     <title>Blockquotes</title>

     <para>Blockqoutes are easy, and support a lot of the other
     elements, too:</para>

     <example>
       <programlisting><xi:include href="./blockquotes.xml" parse="text" /></programlisting>
       <xi:include href="./blockquotes.xml" />
     </example>
   </section>

   <section xml:id="lists">
     <title>Lists</title>

     <para>
       DocBook supports ordered and unordered lists.
     </para>

     <example>
       <programlisting><xi:include href="./list-unordered.xml" parse="text" /></programlisting>
       <xi:include href="./list-unordered.xml" />
     </example>

     <example>
       <programlisting><xi:include href="./list-ordered.xml" parse="text" /></programlisting>
       <xi:include href="./list-ordered.xml" />
     </example>

     <para>or a list with multiple paragraphs:</para>

     <example>
       <programlisting><xi:include href="./lists-paras.xml" parse="text" /></programlisting>
       <xi:include href="./lists-paras.xml" />
     </example>

     <para>or a list with a blockquote:</para>

     <example>
       <programlisting><xi:include href="./lists-quote.xml" parse="text" /></programlisting>
       <xi:include href="./lists-quote.xml" />
     </example>

     <para>
       Itâ€™s worth noting that it isn't possible to trigger an
       ordered list by accident.
     </para>
   </section>

   <section xml:id="code-blocks">
     <title>Code Blocks</title>

     <example xml:id="codeblocks-xml-with-bash">
       <programlisting language="xml"><xi:include href="./code-blocks.xml" parse="text" /></programlisting>
       <xi:include href="./code-blocks.xml" />
     </example>

     <note>
       <para>
         If you'll have a lot of <literal>&lt;</literal>s,
         <literal>&gt;</literal>s, or <literal>&amp;</literal>s like
         you're embedding a bunch of XML or HTML, you'll probably want
         to use a <literal>CDATA</literal> section instead of <link
         linkend="special-characters">escaping them all</link>:
       </para>
       <example>
         <programlisting language="xml"><xi:include href="./code-blocks-cdata.xml" parse="text" /></programlisting>
         <xi:include href="./code-blocks-cdata.xml" />
       </example>
     </note>
   </section>
 </chapter>

 <chapter xml:id="span-elements">
   <title>Span Elements</title>
   <section xml:id="links">
     <title>Links</title>

     <para>
       DocBook supports normal URL links:
     </para>

     <example>
       <programlisting><xi:include href="./link-http.xml" parse="text" /></programlisting>
       <xi:include href="./link-http.xml" />
     </example>

     <para>
       and also has a special method for linking within the same
       document:
     </para>

     <example>
       <programlisting><xi:include href="./link-inter.xml" parse="text" /></programlisting>
       <xi:include href="./link-inter.xml" />
     </example>

     <para>
       The name <literal>&lt;xref&gt;</literal> may be a bit weird of
       a name at first. Maybe remembering it like a
       <emphasis>crossreference</emphasis> will help.
     </para>
   </section>

   <section xml:id="emphasis">
     <title>Emphasis</title>
     <para>
       DocBook documents typically only italicize for emphasis, though
       this is depends on how you process your document.
     </para>

     <example>
       <programlisting><xi:include href="./emphasis.xml" parse="text" /></programlisting>
       <xi:include href="./emphasis.xml" />
     </example>
   </section>

   <section xml:id="inline-code">
     <title>Code</title>

     <para>
       To write a bit of code inside a paragraph, wrap it in
       <literal>&lt;literal&gt;&lt;/literal&gt;</literal>:
     </para>

     <example>
       <programlisting><xi:include href="./code-inline.xml" parse="text" /></programlisting>
       <xi:include href="./code-inline.xml" />
     </example>
   </section>
 </chapter>

 <chapter xml:id="miscellaneous">
   <title>Miscellaneous</title>
   <section xml:id="special-characters">
     <title>Escaping Special Characters</title>
     <para>
       DocBook requires the author to escape a few symbols, depending
       on where you are using them.
     </para>
     <table id="escaping-characters">
       <thead>
         <tr>
           <th>Symbol</th>
           <th>How to type it instead</th>
           <th>When</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <td><literal>&lt;</literal></td>
           <td><para><literal>&amp;lt;</literal></para><para>as in <emphasis>less than</emphasis></para></td>
           <td>Everywhere in your document.</td>
         </tr>
         <tr>
           <td><literal>&gt;</literal></td>
           <td><para><literal>&amp;gt;</literal></para><para>as in <emphasis>greater than</emphasis></para></td>
           <td>Everywhere in your document.</td>
         </tr>
         <tr>
           <td><literal>&amp;</literal></td>
           <td><para><literal>&amp;amp;</literal></para><para> as in <emphasis>ampersand</emphasis></para></td>
           <td>Everywhere in your document.</td>
         </tr>
         <tr>
           <td><literal>&quot;</literal></td>
           <td><para><literal>&amp;quot;</literal></para><para>as in <emphasis>quote</emphasis></para></td>
           <td>Only inside attributes using a double quote, like <literal>&lt;foo
           xlink:title=&quot;a &amp;quot;can do&amp;quot; attitude!&quot;&gt;</literal>.</td>
         </tr>
         <tr>
           <td><literal>&apos;</literal></td>
           <td><para><literal>&amp;apos;</literal></para><para>as in <emphasis>apostrophe</emphasis></para></td>
           <td>Only inside attributes using a single quote, like <literal>&lt;foo
           xlink:title=&apos;it isn&amp;apos;t impossible!&apos;&gt;</literal>.</td>
         </tr>
       </tbody>
     </table>
   </section>
 </chapter>

  <chapter xml:id="fancy-stuff">
   <title>Fancy Stuff</title>
   <section xml:id="prompt">
     <title>Prompts in Command Lines</title>
     <para>
       Copy and paste the following commands:
     </para>

     <xi:include href="./screen-prompt.xml" />

     <para>
       You'll notice you only copied the commands, and not the
       prompt's <literal>$ </literal>.
     </para>

     <para>
       With Markdown you might imagine having a special fenced
       codeblock, like

       <programlisting>
```shell-commands
git clone https://github.com/grahamc/docbook.rocks.git
cd docbook.rocks
```</programlisting>

       and having it automatically prefix the lines with an
       unselectable <literal>$ </literal>. This would be interesting,
       but undesirable because you wouldn't want

       <programlisting>
```shell-commands
git clone https://github.com/grahamc/docbook.rocks.git
Cloning into 'docbook.rocks'...
remote: Counting objects: 52, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 52 (delta 19), reused 48 (delta 15), pack-reused 0
Unpacking objects: 100% (52/52), done.
```</programlisting>

       to turn in to

              <programlisting>
```shell-commands
$ git clone https://github.com/grahamc/docbook.rocks.git
$ Cloning into 'docbook.rocks'...
$ remote: Counting objects: 52, done.
$ remote: Compressing objects: 100% (36/36), done.
$ remote: Total 52 (delta 19), reused 48 (delta 15), pack-reused 0
$ Unpacking objects: 100% (52/52), done.
```</programlisting>
     </para>

     <para>
       You might imagine having your parser detect the existing
       prompts and fix them:

       <programlisting>
```shell-commands
$ git clone https:/b/github.com/grahamc/docbook.rocks.git
Cloning into 'docbook.rocks'...
remote: Counting objects: 52, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 52 (delta 19), reused 48 (delta 15), pack-reused 0
Unpacking objects: 100% (52/52), done.
$ cd docbook.rocks
``` </programlisting>

       having it automatically change the <literal>$ </literal> to be
       unselectable.
     </para>

     <para>
       But what about if your prompt changes, like

       <programlisting>
$ su -i
# </programlisting>

       sure you could detect <literal>#</literal> too... but what
       about something fancier, like:
       <programlisting>
$ git clone https:/b/github.com/grahamc/docbook.rocks.git
Cloning into 'docbook.rocks'...
remote: Counting objects: 52, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 52 (delta 19), reused 48 (delta 15), pack-reused 0
Unpacking objects: 100% (52/52), done.
$ cd docbook.rocks
$ nix-shell
[nix-shell:~/docbook.rocks]$
</programlisting>

       Having your markdown processer handle each of these cases is
       quite complicated, and we haven't even addressed cases where
       the prompt may be inside of another program.
     </para>
     <para>
       With DocBook, there is an optional, built-in tag to explicitly
       mark the prompt:

       <programlisting><xi:include href="./screen-prompt.xml"
       parse="text" /></programlisting>
     </para>
   </section>

   <section xml:id="tables">
     <title>Tables</title>

     <para>
       If you've done any HTML, you'll have no trouble with DocBook
       tables.
     </para>

     <programlisting><xi:include href="./tables.xml" parse="text" /></programlisting>
     <xi:include href="./tables.xml" />
   </section>
  </chapter>

  <colophon>
    <para>
      Built with <link xlink:href="https://nixos.org/nix">Nix</link>,
      DocBook, and HighlighterJS. The text is authored by
      <author><firstname>Graham</firstname> <surname>Christensen</surname></author>.
      The source can be found at <link xlink:href="https://github.com/grahamc/docbook.rocks"
      />. This document is licensed CC-BY-SA-4.0.
    </para>
  </colophon>
</book>
